#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include "Memory.h"

std::uintptr_t Memory::GetProcessID(const char* processName) {
	std::uintptr_t processID = 0;

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (snapshot == INVALID_HANDLE_VALUE) {
		std::cout << "Couldn't get running processes.\n";
		return 0;
	}

	PROCESSENTRY32 processEntry;
	processEntry.dwSize = sizeof(PROCESSENTRY32);

	if (!Process32First(snapshot, &processEntry)) {
		CloseHandle(snapshot);
		std::cout << "Couldn't get info of processes.\n";
		return 0;
	}

	do {
		if (!strcmp(processEntry.szExeFile, processName)) {
			processID = processEntry.th32ProcessID;
			break;
		}
	} while (Process32Next(snapshot, &processEntry));

	CloseHandle(snapshot);

	return processID;
}

std::uintptr_t Memory::GetModuleBaseAddress(std::uintptr_t processID, const char* moduleName) {
	std::uintptr_t moduleBaseAddress = 0;

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, processID);
	if (snapshot == INVALID_HANDLE_VALUE) {
		std::cout << "Couldn't get modules.\n";
		return 0;
	}

	MODULEENTRY32 moduleEntry;
	moduleEntry.dwSize = sizeof(moduleEntry);

	if (!Module32First(snapshot, &moduleEntry)) {
		CloseHandle(snapshot);
		std::cout << "Couldn't get info of modules.\n";
		return 0;
	}

	do {
		if (!strcmp(moduleEntry.szModule, moduleName)) {
			moduleBaseAddress = reinterpret_cast<std::uintptr_t>(moduleEntry.modBaseAddr);
			break;
		}
	} while (Module32Next(snapshot, &moduleEntry));

	CloseHandle(snapshot);

	return moduleBaseAddress;
}